{"ast":null,"code":"import { Box3, BufferAttribute, BufferGeometry, Color, EventDispatcher, Float32BufferAttribute, Matrix3, Matrix4, MathUtils, Object3D, Sphere, Vector2, Vector3 } from 'three';\n\nconst _m1 = new Matrix4();\n\nconst _obj = new Object3D();\n\nconst _offset = new Vector3();\n\nclass Geometry extends EventDispatcher {\n  constructor() {\n    super();\n    this.uuid = MathUtils.generateUUID();\n    this.name = '';\n    this.type = 'Geometry';\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.elementsNeedUpdate = false;\n    this.verticesNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.lineDistancesNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  applyMatrix4(matrix) {\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const vertex = this.vertices[i];\n      vertex.applyMatrix4(matrix);\n    }\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.normal.applyMatrix3(normalMatrix).normalize();\n\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n      }\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    this.verticesNeedUpdate = true;\n    this.normalsNeedUpdate = true;\n    return this;\n  }\n\n  rotateX(angle) {\n    // rotate geometry around world x-axis\n    _m1.makeRotationX(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateY(angle) {\n    // rotate geometry around world y-axis\n    _m1.makeRotationY(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateZ(angle) {\n    // rotate geometry around world z-axis\n    _m1.makeRotationZ(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  translate(x, y, z) {\n    // translate geometry\n    _m1.makeTranslation(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  scale(x, y, z) {\n    // scale geometry\n    _m1.makeScale(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  lookAt(vector) {\n    _obj.lookAt(vector);\n\n    _obj.updateMatrix();\n\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n\n  fromBufferGeometry(geometry) {\n    const scope = this;\n    const index = geometry.index !== null ? geometry.index : undefined;\n    const attributes = geometry.attributes;\n\n    if (attributes.position === undefined) {\n      console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');\n      return this;\n    }\n\n    const position = attributes.position;\n    const normal = attributes.normal;\n    const color = attributes.color;\n    const uv = attributes.uv;\n    const uv2 = attributes.uv2;\n    if (uv2 !== undefined) this.faceVertexUvs[1] = [];\n\n    for (let i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n\n      if (color !== undefined) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i));\n      }\n    }\n\n    function addFace(a, b, c, materialIndex) {\n      const vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n      const vertexNormals = normal === undefined ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n      scope.faces.push(face);\n\n      if (uv !== undefined) {\n        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\n      }\n\n      if (uv2 !== undefined) {\n        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\n      }\n    }\n\n    const groups = geometry.groups;\n\n    if (groups.length > 0) {\n      for (let i = 0; i < groups.length; i++) {\n        const group = groups[i];\n        const start = group.start;\n        const count = group.count;\n\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== undefined) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex);\n          }\n        }\n      }\n    } else {\n      if (index !== undefined) {\n        for (let i = 0; i < index.count; i += 3) {\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n        }\n      } else {\n        for (let i = 0; i < position.count; i += 3) {\n          addFace(i, i + 1, i + 2);\n        }\n      }\n    }\n\n    this.computeFaceNormals();\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    return this;\n  }\n\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n\n  normalize() {\n    this.computeBoundingSphere();\n    const center = this.boundingSphere.center;\n    const radius = this.boundingSphere.radius;\n    const s = radius === 0 ? 1 : 1.0 / radius;\n    const matrix = new Matrix4();\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n    this.applyMatrix4(matrix);\n    return this;\n  }\n\n  computeFaceNormals() {\n    const cb = new Vector3(),\n          ab = new Vector3();\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vA = this.vertices[face.a];\n      const vB = this.vertices[face.b];\n      const vC = this.vertices[face.c];\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab);\n      cb.normalize();\n      face.normal.copy(cb);\n    }\n  }\n\n  computeVertexNormals(areaWeighted = true) {\n    const vertices = new Array(this.vertices.length);\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3();\n    }\n\n    if (areaWeighted) {\n      // vertex normals weighted by triangle areas\n      // http://www.iquilezles.org/www/articles/normals/normals.htm\n      const cb = new Vector3(),\n            ab = new Vector3();\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const vA = this.vertices[face.a];\n        const vB = this.vertices[face.b];\n        const vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        vertices[face.a].add(cb);\n        vertices[face.b].add(cb);\n        vertices[face.c].add(cb);\n      }\n    } else {\n      this.computeFaceNormals();\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        vertices[face.a].add(face.normal);\n        vertices[face.b].add(face.normal);\n        vertices[face.c].add(face.normal);\n      }\n    }\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize();\n    }\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a]);\n        vertexNormals[1].copy(vertices[face.b]);\n        vertexNormals[2].copy(vertices[face.c]);\n      } else {\n        vertexNormals[0] = vertices[face.a].clone();\n        vertexNormals[1] = vertices[face.b].clone();\n        vertexNormals[2] = vertices[face.c].clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n\n  computeFlatVertexNormals() {\n    this.computeFaceNormals();\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal);\n        vertexNormals[1].copy(face.normal);\n        vertexNormals[2].copy(face.normal);\n      } else {\n        vertexNormals[0] = face.normal.clone();\n        vertexNormals[1] = face.normal.clone();\n        vertexNormals[2] = face.normal.clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n\n  computeMorphNormals() {\n    // save original normals\n    // - create temp variables on first access\n    //   otherwise just copy (for faster repeated calls)\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone();\n      } else {\n        face.__originalFaceNormal.copy(face.normal);\n      }\n\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n        }\n      }\n    } // use temp geometry to compute face and vertex normals for each morph\n\n\n    const tmpGeo = new Geometry();\n    tmpGeo.faces = this.faces;\n\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n      // create on first access\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {};\n        this.morphNormals[i].faceNormals = [];\n        this.morphNormals[i].vertexNormals = [];\n        const dstNormalsFace = this.morphNormals[i].faceNormals;\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals;\n\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const faceNormal = new Vector3();\n          const vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3()\n          };\n          dstNormalsFace.push(faceNormal);\n          dstNormalsVertex.push(vertexNormals);\n        }\n      }\n\n      const morphNormals = this.morphNormals[i]; // set vertices to morph target\n\n      tmpGeo.vertices = this.morphTargets[i].vertices; // compute morph normals\n\n      tmpGeo.computeFaceNormals();\n      tmpGeo.computeVertexNormals(); // store morph normals\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const faceNormal = morphNormals.faceNormals[f];\n        const vertexNormals = morphNormals.vertexNormals[f];\n        faceNormal.copy(face.normal);\n        vertexNormals.a.copy(face.vertexNormals[0]);\n        vertexNormals.b.copy(face.vertexNormals[1]);\n        vertexNormals.c.copy(face.vertexNormals[2]);\n      }\n    } // restore original normals\n\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      face.normal = face.__originalFaceNormal;\n      face.vertexNormals = face.__originalVertexNormals;\n    }\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    this.boundingBox.setFromPoints(this.vertices);\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    this.boundingSphere.setFromPoints(this.vertices);\n  }\n\n  merge(geometry, matrix, materialIndexOffset = 0) {\n    if (!(geometry && geometry.isGeometry)) {\n      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\n      return;\n    }\n\n    let normalMatrix;\n    const vertexOffset = this.vertices.length,\n          vertices1 = this.vertices,\n          vertices2 = geometry.vertices,\n          faces1 = this.faces,\n          faces2 = geometry.faces,\n          colors1 = this.colors,\n          colors2 = geometry.colors;\n\n    if (matrix !== undefined) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    } // vertices\n\n\n    for (let i = 0, il = vertices2.length; i < il; i++) {\n      const vertex = vertices2[i];\n      const vertexCopy = vertex.clone();\n      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\n      vertices1.push(vertexCopy);\n    } // colors\n\n\n    for (let i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone());\n    } // faces\n\n\n    for (let i = 0, il = faces2.length; i < il; i++) {\n      const face = faces2[i];\n      let normal, color;\n      const faceVertexNormals = face.vertexNormals,\n            faceVertexColors = face.vertexColors;\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n      faceCopy.normal.copy(face.normal);\n\n      if (normalMatrix !== undefined) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n      }\n\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone();\n\n        if (normalMatrix !== undefined) {\n          normal.applyMatrix3(normalMatrix).normalize();\n        }\n\n        faceCopy.vertexNormals.push(normal);\n      }\n\n      faceCopy.color.copy(face.color);\n\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j];\n        faceCopy.vertexColors.push(color.clone());\n      }\n\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n      faces1.push(faceCopy);\n    } // uvs\n\n\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs2 = geometry.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];\n\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        const uvs2 = faceVertexUvs2[j],\n              uvsCopy = [];\n\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n  }\n\n  mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\n      return;\n    }\n\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n    this.merge(mesh.geometry, mesh.matrix);\n  }\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n\n\n  mergeVertices(precisionPoints = 4) {\n    const verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\n    const unique = [],\n          changes = [];\n    const precision = Math.pow(10, precisionPoints);\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const v = this.vertices[i];\n      const key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);\n\n      if (verticesMap[key] === undefined) {\n        verticesMap[key] = i;\n        unique.push(this.vertices[i]);\n        changes[i] = unique.length - 1;\n      } else {\n        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n        changes[i] = changes[verticesMap[key]];\n      }\n    } // if faces are completely degenerate after merging vertices, we\n    // have to remove them from the geometry.\n\n\n    const faceIndicesToRemove = [];\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.a = changes[face.a];\n      face.b = changes[face.b];\n      face.c = changes[face.c];\n      const indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3\n      // we have to remove the face as nothing can be saved\n\n      for (let n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i);\n          break;\n        }\n      }\n    }\n\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      const idx = faceIndicesToRemove[i];\n      this.faces.splice(idx, 1);\n\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1);\n      }\n    } // Use unique set of vertices\n\n\n    const diff = this.vertices.length - unique.length;\n    this.vertices = unique;\n    return diff;\n  }\n\n  setFromPoints(points) {\n    this.vertices = [];\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n    }\n\n    return this;\n  }\n\n  sortFacesByMaterialIndex() {\n    const faces = this.faces;\n    const length = faces.length; // tag faces\n\n    for (let i = 0; i < length; i++) {\n      faces[i]._id = i;\n    } // sort faces\n\n\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex;\n    }\n\n    faces.sort(materialIndexSort); // sort uvs\n\n    const uvs1 = this.faceVertexUvs[0];\n    const uvs2 = this.faceVertexUvs[1];\n    let newUvs1, newUvs2;\n    if (uvs1 && uvs1.length === length) newUvs1 = [];\n    if (uvs2 && uvs2.length === length) newUvs2 = [];\n\n    for (let i = 0; i < length; i++) {\n      const id = faces[i]._id;\n      if (newUvs1) newUvs1.push(uvs1[id]);\n      if (newUvs2) newUvs2.push(uvs2[id]);\n    }\n\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Geometry',\n        generator: 'Geometry.toJSON'\n      }\n    }; // standard Geometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters;\n\n      for (const key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n\n      return data;\n    }\n\n    const vertices = [];\n\n    for (let i = 0; i < this.vertices.length; i++) {\n      const vertex = this.vertices[i];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n\n    const faces = [];\n    const normals = [];\n    const normalsHash = {};\n    const colors = [];\n    const colorsHash = {};\n    const uvs = [];\n    const uvsHash = {};\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const hasMaterial = true;\n      const hasFaceUv = false; // deprecated\n\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\n      const hasFaceNormal = face.normal.length() > 0;\n      const hasFaceVertexNormal = face.vertexNormals.length > 0;\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n      const hasFaceVertexColor = face.vertexColors.length > 0;\n      let faceType = 0;\n      faceType = setBit(faceType, 0, 0); // isQuad\n\n      faceType = setBit(faceType, 1, hasMaterial);\n      faceType = setBit(faceType, 2, hasFaceUv);\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\n      faceType = setBit(faceType, 4, hasFaceNormal);\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\n      faceType = setBit(faceType, 6, hasFaceColor);\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\n      faces.push(faceType);\n      faces.push(face.a, face.b, face.c);\n      faces.push(face.materialIndex);\n\n      if (hasFaceVertexUv) {\n        const faceVertexUvs = this.faceVertexUvs[0][i];\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n      }\n\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal));\n      }\n\n      if (hasFaceVertexNormal) {\n        const vertexNormals = face.vertexNormals;\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n      }\n\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color));\n      }\n\n      if (hasFaceVertexColor) {\n        const vertexColors = face.vertexColors;\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n      }\n    }\n\n    function setBit(value, position, enabled) {\n      return enabled ? value | 1 << position : value & ~(1 << position);\n    }\n\n    function getNormalIndex(normal) {\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n      if (normalsHash[hash] !== undefined) {\n        return normalsHash[hash];\n      }\n\n      normalsHash[hash] = normals.length / 3;\n      normals.push(normal.x, normal.y, normal.z);\n      return normalsHash[hash];\n    }\n\n    function getColorIndex(color) {\n      const hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n      if (colorsHash[hash] !== undefined) {\n        return colorsHash[hash];\n      }\n\n      colorsHash[hash] = colors.length;\n      colors.push(color.getHex());\n      return colorsHash[hash];\n    }\n\n    function getUvIndex(uv) {\n      const hash = uv.x.toString() + uv.y.toString();\n\n      if (uvsHash[hash] !== undefined) {\n        return uvsHash[hash];\n      }\n\n      uvsHash[hash] = uvs.length / 2;\n      uvs.push(uv.x, uv.y);\n      return uvsHash[hash];\n    }\n\n    data.data = {};\n    data.data.vertices = vertices;\n    data.data.normals = normals;\n    if (colors.length > 0) data.data.colors = colors;\n    if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\n\n    data.data.faces = faces;\n    return data;\n  }\n\n  clone() {\n    /*\n     // Handle primitives\n    \t const parameters = this.parameters;\n    \t if ( parameters !== undefined ) {\n    \t const values = [];\n    \t for ( const key in parameters ) {\n    \t values.push( parameters[ key ] );\n    \t }\n    \t const geometry = Object.create( this.constructor.prototype );\n     this.constructor.apply( geometry, values );\n     return geometry;\n    \t }\n    \t return new this.constructor().copy( this );\n     */\n    return new Geometry().copy(this);\n  }\n\n  copy(source) {\n    // reset\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // name\n\n    this.name = source.name; // vertices\n\n    const vertices = source.vertices;\n\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone());\n    } // colors\n\n\n    const colors = source.colors;\n\n    for (let i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone());\n    } // faces\n\n\n    const faces = source.faces;\n\n    for (let i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone());\n    } // face vertex uvs\n\n\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs = source.faceVertexUvs[i];\n\n      if (this.faceVertexUvs[i] === undefined) {\n        this.faceVertexUvs[i] = [];\n      }\n\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        const uvs = faceVertexUvs[j],\n              uvsCopy = [];\n\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\n          const uv = uvs[k];\n          uvsCopy.push(uv.clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    } // morph targets\n\n\n    const morphTargets = source.morphTargets;\n\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = {};\n      morphTarget.name = morphTargets[i].name; // vertices\n\n      if (morphTargets[i].vertices !== undefined) {\n        morphTarget.vertices = [];\n\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n        }\n      } // normals\n\n\n      if (morphTargets[i].normals !== undefined) {\n        morphTarget.normals = [];\n\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone());\n        }\n      }\n\n      this.morphTargets.push(morphTarget);\n    } // morph normals\n\n\n    const morphNormals = source.morphNormals;\n\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\n      const morphNormal = {}; // vertex normals\n\n      if (morphNormals[i].vertexNormals !== undefined) {\n        morphNormal.vertexNormals = [];\n\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          const srcVertexNormal = morphNormals[i].vertexNormals[j];\n          const destVertexNormal = {};\n          destVertexNormal.a = srcVertexNormal.a.clone();\n          destVertexNormal.b = srcVertexNormal.b.clone();\n          destVertexNormal.c = srcVertexNormal.c.clone();\n          morphNormal.vertexNormals.push(destVertexNormal);\n        }\n      } // face normals\n\n\n      if (morphNormals[i].faceNormals !== undefined) {\n        morphNormal.faceNormals = [];\n\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n        }\n      }\n\n      this.morphNormals.push(morphNormal);\n    } // skin weights\n\n\n    const skinWeights = source.skinWeights;\n\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone());\n    } // skin indices\n\n\n    const skinIndices = source.skinIndices;\n\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone());\n    } // line distances\n\n\n    const lineDistances = source.lineDistances;\n\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i]);\n    } // bounding box\n\n\n    const boundingBox = source.boundingBox;\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    } // bounding sphere\n\n\n    const boundingSphere = source.boundingSphere;\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    } // update flags\n\n\n    this.elementsNeedUpdate = source.elementsNeedUpdate;\n    this.verticesNeedUpdate = source.verticesNeedUpdate;\n    this.uvsNeedUpdate = source.uvsNeedUpdate;\n    this.normalsNeedUpdate = source.normalsNeedUpdate;\n    this.colorsNeedUpdate = source.colorsNeedUpdate;\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n    this.groupsNeedUpdate = source.groupsNeedUpdate;\n    return this;\n  }\n\n  toBufferGeometry() {\n    const geometry = new DirectGeometry().fromGeometry(this);\n    const buffergeometry = new BufferGeometry();\n    const positions = new Float32Array(geometry.vertices.length * 3);\n    buffergeometry.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n\n    if (geometry.normals.length > 0) {\n      const normals = new Float32Array(geometry.normals.length * 3);\n      buffergeometry.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n    }\n\n    if (geometry.colors.length > 0) {\n      const colors = new Float32Array(geometry.colors.length * 3);\n      buffergeometry.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n    }\n\n    if (geometry.uvs.length > 0) {\n      const uvs = new Float32Array(geometry.uvs.length * 2);\n      buffergeometry.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n    }\n\n    if (geometry.uvs2.length > 0) {\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2);\n      buffergeometry.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n    } // groups\n\n\n    buffergeometry.groups = geometry.groups; // morphs\n\n    for (const name in geometry.morphTargets) {\n      const array = [];\n      const morphTargets = geometry.morphTargets[name];\n\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\n        const morphTarget = morphTargets[i];\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n        attribute.name = morphTarget.name;\n        array.push(attribute.copyVector3sArray(morphTarget.data));\n      }\n\n      buffergeometry.morphAttributes[name] = array;\n    } // skinning\n\n\n    if (geometry.skinIndices.length > 0) {\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n      buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\n    }\n\n    if (geometry.skinWeights.length > 0) {\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n      buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\n    } //\n\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return buffergeometry;\n  }\n\n  computeTangents() {\n    console.error('THREE.Geometry: .computeTangents() has been removed.');\n  }\n\n  computeLineDistances() {\n    console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n  static createBufferGeometryFromObject(object) {\n    let buffergeometry = new BufferGeometry();\n    const geometry = object.geometry;\n\n    if (object.isPoints || object.isLine) {\n      const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n      const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n      buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\n      buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors));\n\n      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n        const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n        buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\n      }\n\n      if (geometry.boundingSphere !== null) {\n        buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n      }\n\n      if (geometry.boundingBox !== null) {\n        buffergeometry.boundingBox = geometry.boundingBox.clone();\n      }\n    } else if (object.isMesh) {\n      buffergeometry = geometry.toBufferGeometry();\n    }\n\n    return buffergeometry;\n  }\n\n}\n\nGeometry.prototype.isGeometry = true;\n\nclass DirectGeometry {\n  constructor() {\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = []; // this.lineDistances = [];\n\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  computeGroups(geometry) {\n    const groups = [];\n    let group, i;\n    let materialIndex = undefined;\n    const faces = geometry.faces;\n\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i]; // materials\n\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex;\n\n        if (group !== undefined) {\n          group.count = i * 3 - group.start;\n          groups.push(group);\n        }\n\n        group = {\n          start: i * 3,\n          materialIndex: materialIndex\n        };\n      }\n    }\n\n    if (group !== undefined) {\n      group.count = i * 3 - group.start;\n      groups.push(group);\n    }\n\n    this.groups = groups;\n  }\n\n  fromGeometry(geometry) {\n    const faces = geometry.faces;\n    const vertices = geometry.vertices;\n    const faceVertexUvs = geometry.faceVertexUvs;\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs\n\n    const morphTargets = geometry.morphTargets;\n    const morphTargetsLength = morphTargets.length;\n    let morphTargetsPosition;\n\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = [];\n\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: []\n        };\n      }\n\n      this.morphTargets.position = morphTargetsPosition;\n    }\n\n    const morphNormals = geometry.morphNormals;\n    const morphNormalsLength = morphNormals.length;\n    let morphTargetsNormal;\n\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = [];\n\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: []\n        };\n      }\n\n      this.morphTargets.normal = morphTargetsNormal;\n    } // skins\n\n\n    const skinIndices = geometry.skinIndices;\n    const skinWeights = geometry.skinWeights;\n    const hasSkinIndices = skinIndices.length === vertices.length;\n    const hasSkinWeights = skinWeights.length === vertices.length; //\n\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error('THREE.DirectGeometry: Faceless geometries are not supported.');\n    }\n\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n      } else {\n        const normal = face.normal;\n        this.normals.push(normal, normal, normal);\n      }\n\n      const vertexColors = face.vertexColors;\n\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n      } else {\n        const color = face.color;\n        this.colors.push(color, color, color);\n      }\n\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i];\n\n        if (vertexUvs !== undefined) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i];\n\n        if (vertexUvs !== undefined) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      } // morphs\n\n\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices;\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n      }\n\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i];\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n      } // skins\n\n\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n      }\n\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n      }\n    }\n\n    this.computeGroups(geometry);\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return this;\n  }\n\n}\n\nclass Face3 {\n  constructor(a, b, c, normal, color, materialIndex = 0) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.a = source.a;\n    this.b = source.b;\n    this.c = source.c;\n    this.normal.copy(source.normal);\n    this.color.copy(source.color);\n    this.materialIndex = source.materialIndex;\n\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone();\n    }\n\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone();\n    }\n\n    return this;\n  }\n\n}\n\nexport { Face3, Geometry };","map":{"version":3,"sources":["/Users/axelholmqvist/Developer/axelholmqvist-se/node_modules/three/examples/jsm/deprecated/Geometry.js"],"names":["Box3","BufferAttribute","BufferGeometry","Color","EventDispatcher","Float32BufferAttribute","Matrix3","Matrix4","MathUtils","Object3D","Sphere","Vector2","Vector3","_m1","_obj","_offset","Geometry","constructor","uuid","generateUUID","name","type","vertices","colors","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","lineDistances","boundingBox","boundingSphere","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","applyMatrix4","matrix","normalMatrix","getNormalMatrix","i","il","length","vertex","face","normal","applyMatrix3","normalize","j","jl","vertexNormals","computeBoundingBox","computeBoundingSphere","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","fromBufferGeometry","geometry","scope","index","undefined","attributes","position","console","error","color","uv","uv2","count","push","fromBufferAttribute","addFace","a","b","c","materialIndex","vertexColors","clone","Face3","groups","group","start","getX","computeFaceNormals","center","getCenter","negate","radius","s","set","cb","ab","f","fl","vA","vB","vC","subVectors","cross","copy","computeVertexNormals","areaWeighted","Array","v","vl","add","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","dstNormalsFace","dstNormalsVertex","faceNormal","setFromPoints","merge","materialIndexOffset","isGeometry","vertexOffset","vertices1","vertices2","faces1","faces2","colors1","colors2","vertexCopy","faceVertexNormals","faceVertexColors","faceCopy","faceVertexUvs2","uvs2","uvsCopy","k","kl","mergeMesh","mesh","isMesh","matrixAutoUpdate","mergeVertices","precisionPoints","verticesMap","unique","changes","precision","Math","pow","key","round","faceIndicesToRemove","indices","n","idx","splice","diff","points","l","point","sortFacesByMaterialIndex","_id","materialIndexSort","sort","uvs1","newUvs1","newUvs2","id","toJSON","data","metadata","version","generator","parameters","normals","normalsHash","colorsHash","uvs","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","r","g","hasFaceVertexColor","faceType","setBit","getUvIndex","getNormalIndex","getColorIndex","value","enabled","hash","toString","getHex","source","morphTarget","morphNormal","srcVertexNormal","destVertexNormal","toBufferGeometry","DirectGeometry","fromGeometry","buffergeometry","positions","Float32Array","setAttribute","copyVector3sArray","copyColorsArray","copyVector2sArray","array","attribute","morphAttributes","copyVector4sArray","computeTangents","computeLineDistances","applyMatrix","warn","dispose","dispatchEvent","createBufferGeometryFromObject","object","isPoints","isLine","copyArray","prototype","computeGroups","hasFaceVertexUv2","morphTargetsLength","morphTargetsPosition","morphNormalsLength","morphTargetsNormal","hasSkinIndices","hasSkinWeights","vertexUvs","isVector3","isArray","isColor"],"mappings":"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","sourcesContent":["import {\n\tBox3,\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tEventDispatcher,\n\tFloat32BufferAttribute,\n\tMatrix3,\n\tMatrix4,\n\tMathUtils,\n\tObject3D,\n\tSphere,\n\tVector2,\n\tVector3\n} from 'three';\n\nconst _m1 = new Matrix4();\nconst _obj = new Object3D();\nconst _offset = new Vector3();\n\nclass Geometry extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Geometry';\n\n\t\tthis.vertices = [];\n\t\tthis.colors = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [[]];\n\n\t\tthis.morphTargets = [];\n\t\tthis.morphNormals = [];\n\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\n\t\tthis.lineDistances = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// update flags\n\n\t\tthis.elementsNeedUpdate = false;\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.lineDistancesNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\tfor ( let i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tconst vertex = this.vertices[ i ];\n\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tfor ( let j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.verticesNeedUpdate = true;\n\t\tthis.normalsNeedUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\tfromBufferGeometry( geometry ) {\n\n\t\tconst scope = this;\n\n\t\tconst index = geometry.index !== null ? geometry.index : undefined;\n\t\tconst attributes = geometry.attributes;\n\n\t\tif ( attributes.position === undefined ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst position = attributes.position;\n\t\tconst normal = attributes.normal;\n\t\tconst color = attributes.color;\n\t\tconst uv = attributes.uv;\n\t\tconst uv2 = attributes.uv2;\n\n\t\tif ( uv2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\tscope.vertices.push( new Vector3().fromBufferAttribute( position, i ) );\n\n\t\t\tif ( color !== undefined ) {\n\n\t\t\t\tscope.colors.push( new Color().fromBufferAttribute( color, i ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\tconst vertexColors = ( color === undefined ) ? [] : [\n\t\t\t\tscope.colors[ a ].clone(),\n\t\t\t\tscope.colors[ b ].clone(),\n\t\t\t\tscope.colors[ c ].clone()\n\t\t\t];\n\n\t\t\tconst vertexNormals = ( normal === undefined ) ? [] : [\n\t\t\t\tnew Vector3().fromBufferAttribute( normal, a ),\n\t\t\t\tnew Vector3().fromBufferAttribute( normal, b ),\n\t\t\t\tnew Vector3().fromBufferAttribute( normal, c )\n\t\t\t];\n\n\t\t\tconst face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\tscope.faces.push( face );\n\n\t\t\tif ( uv !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv, a ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv, b ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv, c )\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( uv2 !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv2, a ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv2, b ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv2, c )\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst groups = geometry.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\tconst start = group.start;\n\t\t\t\tconst count = group.count;\n\n\t\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\t\taddFace( index.getX( j ), index.getX( j + 1 ), index.getX( j + 2 ), group.materialIndex );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\taddFace( j, j + 1, j + 2, group.materialIndex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < index.count; i += 3 ) {\n\n\t\t\t\t\taddFace( index.getX( i ), index.getX( i + 1 ), index.getX( i + 2 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i += 3 ) {\n\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeFaceNormals();\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\tnormalize() {\n\n\t\tthis.computeBoundingSphere();\n\n\t\tconst center = this.boundingSphere.center;\n\t\tconst radius = this.boundingSphere.radius;\n\n\t\tconst s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\tconst matrix = new Matrix4();\n\t\tmatrix.set(\n\t\t\ts, 0, 0, - s * center.x,\n\t\t\t0, s, 0, - s * center.y,\n\t\t\t0, 0, s, - s * center.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\tthis.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t}\n\n\tcomputeFaceNormals() {\n\n\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tconst vA = this.vertices[ face.a ];\n\t\t\tconst vB = this.vertices[ face.b ];\n\t\t\tconst vC = this.vertices[ face.c ];\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab );\n\n\t\t\tcb.normalize();\n\n\t\t\tface.normal.copy( cb );\n\n\t\t}\n\n\t}\n\n\tcomputeVertexNormals( areaWeighted = true ) {\n\n\t\tconst vertices = new Array( this.vertices.length );\n\n\t\tfor ( let v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ] = new Vector3();\n\n\t\t}\n\n\t\tif ( areaWeighted ) {\n\n\t\t\t// vertex normals weighted by triangle areas\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tconst face = this.faces[ f ];\n\n\t\t\t\tconst vA = this.vertices[ face.a ];\n\t\t\t\tconst vB = this.vertices[ face.b ];\n\t\t\t\tconst vC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tconst face = this.faces[ f ];\n\n\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ].normalize();\n\n\t\t}\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t}\n\n\tcomputeFlatVertexNormals() {\n\n\t\tthis.computeFaceNormals();\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\n\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\n\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\n\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\n\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t}\n\n\tcomputeMorphNormals() {\n\n\t\t// save original normals\n\t\t// - create temp variables on first access\n\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t} else {\n\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t}\n\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\tfor ( let i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\tconst tmpGeo = new Geometry();\n\t\ttmpGeo.faces = this.faces;\n\n\t\tfor ( let i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t// create on first access\n\n\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\tconst dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\tconst dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tconst faceNormal = new Vector3();\n\t\t\t\t\tconst vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst morphNormals = this.morphNormals[ i ];\n\n\t\t\t// set vertices to morph target\n\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t// compute morph normals\n\n\t\t\ttmpGeo.computeFaceNormals();\n\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t// store morph normals\n\n\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tconst face = this.faces[ f ];\n\n\t\t\t\tconst faceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\tconst vertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore original normals\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t}\n\n\tmerge( geometry, matrix, materialIndexOffset = 0 ) {\n\n\t\tif ( ! ( geometry && geometry.isGeometry ) ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet normalMatrix;\n\t\tconst vertexOffset = this.vertices.length,\n\t\t\tvertices1 = this.vertices,\n\t\t\tvertices2 = geometry.vertices,\n\t\t\tfaces1 = this.faces,\n\t\t\tfaces2 = geometry.faces,\n\t\t\tcolors1 = this.colors,\n\t\t\tcolors2 = geometry.colors;\n\n\t\tif ( matrix !== undefined ) {\n\n\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( let i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\tconst vertex = vertices2[ i ];\n\n\t\t\tconst vertexCopy = vertex.clone();\n\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\tvertices1.push( vertexCopy );\n\n\t\t}\n\n\t\t// colors\n\n\t\tfor ( let i = 0, il = colors2.length; i < il; i ++ ) {\n\n\t\t\tcolors1.push( colors2[ i ].clone() );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( let i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\tconst face = faces2[ i ];\n\t\t\tlet normal, color;\n\t\t\tconst faceVertexNormals = face.vertexNormals,\n\t\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\tconst faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t}\n\n\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\tfor ( let j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t}\n\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\tfaces1.push( faceCopy );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( let i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tconst faceVertexUvs2 = geometry.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) this.faceVertexUvs[ i ] = [];\n\n\t\t\tfor ( let j = 0, jl = faceVertexUvs2.length; j < jl; j ++ ) {\n\n\t\t\t\tconst uvs2 = faceVertexUvs2[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( let k = 0, kl = uvs2.length; k < kl; k ++ ) {\n\n\t\t\t\t\tuvsCopy.push( uvs2[ k ].clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tmergeMesh( mesh ) {\n\n\t\tif ( ! ( mesh && mesh.isMesh ) ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( mesh.matrixAutoUpdate ) mesh.updateMatrix();\n\n\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t}\n\n\t/*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */\n\n\tmergeVertices( precisionPoints = 4 ) {\n\n\t\tconst verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\tconst unique = [], changes = [];\n\n\t\tconst precision = Math.pow( 10, precisionPoints );\n\n\t\tfor ( let i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tconst v = this.vertices[ i ];\n\t\t\tconst key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// if faces are completely degenerate after merging vertices, we\n\t\t// have to remove them from the geometry.\n\t\tconst faceIndicesToRemove = [];\n\n\t\tfor ( let i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\n\t\t\tface.a = changes[ face.a ];\n\t\t\tface.b = changes[ face.b ];\n\t\t\tface.c = changes[ face.c ];\n\n\t\t\tconst indices = [ face.a, face.b, face.c ];\n\n\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t// we have to remove the face as nothing can be saved\n\t\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\tconst idx = faceIndicesToRemove[ i ];\n\n\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\tfor ( let j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Use unique set of vertices\n\n\t\tconst diff = this.vertices.length - unique.length;\n\t\tthis.vertices = unique;\n\t\treturn diff;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.vertices = [];\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst point = points[ i ];\n\t\t\tthis.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsortFacesByMaterialIndex() {\n\n\t\tconst faces = this.faces;\n\t\tconst length = faces.length;\n\n\t\t// tag faces\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tfaces[ i ]._id = i;\n\n\t\t}\n\n\t\t// sort faces\n\n\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t}\n\n\t\tfaces.sort( materialIndexSort );\n\n\t\t// sort uvs\n\n\t\tconst uvs1 = this.faceVertexUvs[ 0 ];\n\t\tconst uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\tlet newUvs1, newUvs2;\n\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst id = faces[ i ]._id;\n\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t}\n\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Geometry',\n\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Geometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tconst vertices = [];\n\n\t\tfor ( let i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\tconst vertex = this.vertices[ i ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tconst faces = [];\n\t\tconst normals = [];\n\t\tconst normalsHash = {};\n\t\tconst colors = [];\n\t\tconst colorsHash = {};\n\t\tconst uvs = [];\n\t\tconst uvsHash = {};\n\n\t\tfor ( let i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\n\t\t\tconst hasMaterial = true;\n\t\t\tconst hasFaceUv = false; // deprecated\n\t\t\tconst hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\tconst hasFaceNormal = face.normal.length() > 0;\n\t\t\tconst hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\tconst hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\tconst hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\tlet faceType = 0;\n\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\tfaces.push( faceType );\n\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\tfaces.push( face.materialIndex );\n\n\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\tconst faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\tconst vertexColors = face.vertexColors;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t}\n\n\t\tfunction getNormalIndex( normal ) {\n\n\t\t\tconst hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\treturn normalsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getColorIndex( color ) {\n\n\t\t\tconst hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\tcolors.push( color.getHex() );\n\n\t\t\treturn colorsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getUvIndex( uv ) {\n\n\t\t\tconst hash = uv.x.toString() + uv.y.toString();\n\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\treturn uvsHash[ hash ];\n\n\t\t}\n\n\t\tdata.data = {};\n\n\t\tdata.data.vertices = vertices;\n\t\tdata.data.normals = normals;\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\tdata.data.faces = faces;\n\n\t\treturn data;\n\n\t}\n\n\tclone() {\n\n\t\t/*\n\t\t // Handle primitives\n\n\t\t const parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t const values = [];\n\n\t\t for ( const key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t const geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n\t\treturn new Geometry().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\t// reset\n\n\t\tthis.vertices = [];\n\t\tthis.colors = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [[]];\n\t\tthis.morphTargets = [];\n\t\tthis.morphNormals = [];\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\t\tthis.lineDistances = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// vertices\n\n\t\tconst vertices = source.vertices;\n\n\t\tfor ( let i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t}\n\n\t\t// colors\n\n\t\tconst colors = source.colors;\n\n\t\tfor ( let i = 0, il = colors.length; i < il; i ++ ) {\n\n\t\t\tthis.colors.push( colors[ i ].clone() );\n\n\t\t}\n\n\t\t// faces\n\n\t\tconst faces = source.faces;\n\n\t\tfor ( let i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t}\n\n\t\t// face vertex uvs\n\n\t\tfor ( let i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tconst faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tconst uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( let k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\tconst uv = uvs[ k ];\n\n\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tconst morphTargets = source.morphTargets;\n\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tconst morphTarget = {};\n\t\t\tmorphTarget.name = morphTargets[ i ].name;\n\n\t\t\t// vertices\n\n\t\t\tif ( morphTargets[ i ].vertices !== undefined ) {\n\n\t\t\t\tmorphTarget.vertices = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normals\n\n\t\t\tif ( morphTargets[ i ].normals !== undefined ) {\n\n\t\t\t\tmorphTarget.normals = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.push( morphTarget );\n\n\t\t}\n\n\t\t// morph normals\n\n\t\tconst morphNormals = source.morphNormals;\n\n\t\tfor ( let i = 0, il = morphNormals.length; i < il; i ++ ) {\n\n\t\t\tconst morphNormal = {};\n\n\t\t\t// vertex normals\n\n\t\t\tif ( morphNormals[ i ].vertexNormals !== undefined ) {\n\n\t\t\t\tmorphNormal.vertexNormals = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\n\t\t\t\t\tconst destVertexNormal = {};\n\n\t\t\t\t\tdestVertexNormal.a = srcVertexNormal.a.clone();\n\t\t\t\t\tdestVertexNormal.b = srcVertexNormal.b.clone();\n\t\t\t\t\tdestVertexNormal.c = srcVertexNormal.c.clone();\n\n\t\t\t\t\tmorphNormal.vertexNormals.push( destVertexNormal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// face normals\n\n\t\t\tif ( morphNormals[ i ].faceNormals !== undefined ) {\n\n\t\t\t\tmorphNormal.faceNormals = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.morphNormals.push( morphNormal );\n\n\t\t}\n\n\t\t// skin weights\n\n\t\tconst skinWeights = source.skinWeights;\n\n\t\tfor ( let i = 0, il = skinWeights.length; i < il; i ++ ) {\n\n\t\t\tthis.skinWeights.push( skinWeights[ i ].clone() );\n\n\t\t}\n\n\t\t// skin indices\n\n\t\tconst skinIndices = source.skinIndices;\n\n\t\tfor ( let i = 0, il = skinIndices.length; i < il; i ++ ) {\n\n\t\t\tthis.skinIndices.push( skinIndices[ i ].clone() );\n\n\t\t}\n\n\t\t// line distances\n\n\t\tconst lineDistances = source.lineDistances;\n\n\t\tfor ( let i = 0, il = lineDistances.length; i < il; i ++ ) {\n\n\t\t\tthis.lineDistances.push( lineDistances[ i ] );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// update flags\n\n\t\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\n\t\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\n\t\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\n\t\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\n\t\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n\t\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\n\n\t\treturn this;\n\n\t}\n\n\ttoBufferGeometry() {\n\n\t\tconst geometry = new DirectGeometry().fromGeometry( this );\n\n\t\tconst buffergeometry = new BufferGeometry();\n\n\t\tconst positions = new Float32Array( geometry.vertices.length * 3 );\n\t\tbuffergeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\tconst normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\tbuffergeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t}\n\n\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\tconst colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\tbuffergeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\tconst uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\tbuffergeometry.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\tconst uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\tbuffergeometry.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t}\n\n\t\t// groups\n\n\t\tbuffergeometry.groups = geometry.groups;\n\n\t\t// morphs\n\n\t\tfor ( const name in geometry.morphTargets ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphTargets = geometry.morphTargets[ name ];\n\n\t\t\tfor ( let i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\tconst morphTarget = morphTargets[ i ];\n\n\t\t\t\tconst attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );\n\t\t\t\tattribute.name = morphTarget.name;\n\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget.data ) );\n\n\t\t\t}\n\n\t\t\tbuffergeometry.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\t// skinning\n\n\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\tconst skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\n\t\t\tbuffergeometry.setAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t}\n\n\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\tconst skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\n\t\t\tbuffergeometry.setAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tbuffergeometry.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tbuffergeometry.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn buffergeometry;\n\n\t}\n\n\tcomputeTangents() {\n\n\t\tconsole.error( 'THREE.Geometry: .computeTangents() has been removed.' );\n\n\t}\n\n\tcomputeLineDistances() {\n\n\t\tconsole.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );\n\n\t}\n\n\tapplyMatrix( matrix ) {\n\n\t\tconsole.warn( 'THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().' );\n\t\treturn this.applyMatrix4( matrix );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\tstatic createBufferGeometryFromObject( object ) {\n\n\t\tlet buffergeometry = new BufferGeometry();\n\n\t\tconst geometry = object.geometry;\n\n\t\tif ( object.isPoints || object.isLine ) {\n\n\t\t\tconst positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\n\t\t\tconst colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\n\n\t\t\tbuffergeometry.setAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\tbuffergeometry.setAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\t\tconst lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\n\n\t\t\t\tbuffergeometry.setAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tbuffergeometry.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tbuffergeometry.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t} else if ( object.isMesh ) {\n\n\t\t\tbuffergeometry = geometry.toBufferGeometry();\n\n\t\t}\n\n\t\treturn buffergeometry;\n\n\t}\n\n}\n\nGeometry.prototype.isGeometry = true;\n\nclass DirectGeometry {\n\n\tconstructor() {\n\n\t\tthis.vertices = [];\n\t\tthis.normals = [];\n\t\tthis.colors = [];\n\t\tthis.uvs = [];\n\t\tthis.uvs2 = [];\n\n\t\tthis.groups = [];\n\n\t\tthis.morphTargets = {};\n\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\n\t\t// this.lineDistances = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// update flags\n\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\n\t}\n\n\tcomputeGroups( geometry ) {\n\n\t\tconst groups = [];\n\n\t\tlet group, i;\n\t\tlet materialIndex = undefined;\n\n\t\tconst faces = geometry.faces;\n\n\t\tfor ( i = 0; i < faces.length; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\n\t\t\t// materials\n\n\t\t\tif ( face.materialIndex !== materialIndex ) {\n\n\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t}\n\n\t\t\t\tgroup = {\n\t\t\t\t\tstart: i * 3,\n\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( group !== undefined ) {\n\n\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\tgroups.push( group );\n\n\t\t}\n\n\t\tthis.groups = groups;\n\n\t}\n\n\tfromGeometry( geometry ) {\n\n\t\tconst faces = geometry.faces;\n\t\tconst vertices = geometry.vertices;\n\t\tconst faceVertexUvs = geometry.faceVertexUvs;\n\n\t\tconst hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\tconst hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n\t\t// morphs\n\n\t\tconst morphTargets = geometry.morphTargets;\n\t\tconst morphTargetsLength = morphTargets.length;\n\n\t\tlet morphTargetsPosition;\n\n\t\tif ( morphTargetsLength > 0 ) {\n\n\t\t\tmorphTargetsPosition = [];\n\n\t\t\tfor ( let i = 0; i < morphTargetsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsPosition[ i ] = {\n\t\t\t\t\tname: morphTargets[ i ].name,\n\t\t\t\t \tdata: []\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\n\t\t}\n\n\t\tconst morphNormals = geometry.morphNormals;\n\t\tconst morphNormalsLength = morphNormals.length;\n\n\t\tlet morphTargetsNormal;\n\n\t\tif ( morphNormalsLength > 0 ) {\n\n\t\t\tmorphTargetsNormal = [];\n\n\t\t\tfor ( let i = 0; i < morphNormalsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsNormal[ i ] = {\n\t\t\t\t\tname: morphNormals[ i ].name,\n\t\t\t\t \tdata: []\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\n\t\t}\n\n\t\t// skins\n\n\t\tconst skinIndices = geometry.skinIndices;\n\t\tconst skinWeights = geometry.skinWeights;\n\n\t\tconst hasSkinIndices = skinIndices.length === vertices.length;\n\t\tconst hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t//\n\n\t\tif ( vertices.length > 0 && faces.length === 0 ) {\n\n\t\t\tconsole.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < faces.length; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\n\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tconst normal = face.normal;\n\n\t\t\t\tthis.normals.push( normal, normal, normal );\n\n\t\t\t}\n\n\t\t\tconst vertexColors = face.vertexColors;\n\n\t\t\tif ( vertexColors.length === 3 ) {\n\n\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tconst color = face.color;\n\n\t\t\t\tthis.colors.push( color, color, color );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv === true ) {\n\n\t\t\t\tconst vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n\t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv2 === true ) {\n\n\t\t\t\tconst vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n\t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// morphs\n\n\t\t\tfor ( let j = 0; j < morphTargetsLength; j ++ ) {\n\n\t\t\t\tconst morphTarget = morphTargets[ j ].vertices;\n\n\t\t\t\tmorphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0; j < morphNormalsLength; j ++ ) {\n\n\t\t\t\tconst morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n\t\t\t\tmorphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n\t\t\t}\n\n\t\t\t// skins\n\n\t\t\tif ( hasSkinIndices ) {\n\n\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n\t\t\t}\n\n\t\t\tif ( hasSkinWeights ) {\n\n\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeGroups( geometry );\n\n\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Face3 {\n\n\tconstructor( a, b, c, normal, color, materialIndex = 0 ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\n\t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\n\t\tthis.color = ( color && color.isColor ) ? color : new Color();\n\t\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\n\t\tthis.materialIndex = materialIndex;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.a = source.a;\n\t\tthis.b = source.b;\n\t\tthis.c = source.c;\n\n\t\tthis.normal.copy( source.normal );\n\t\tthis.color.copy( source.color );\n\n\t\tthis.materialIndex = source.materialIndex;\n\n\t\tfor ( let i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\n\t\t}\n\n\t\tfor ( let i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { Face3, Geometry };\n"]},"metadata":{},"sourceType":"module"}